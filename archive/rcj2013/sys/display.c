#include "display.h"

void u8g_DrawLong(uint8_t koord_x, uint8_t koord_y, int32_t num)
{
  char buffer[15];
	ltoa( num , buffer, 10);
  u8g_DrawStr(&u8g, koord_x, koord_y, buffer);
}

const uint8_t logo[] U8G_PROGMEM = {
	0x00, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe,
   0x7f, 0x00, 0x00, 0x00, 0xfc, 0x01, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x80, 0x9f, 0xff, 0xff, 0x00, 0x00, 0x80, 0xff, 0x1f, 0x80, 0xff,
   0x01, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xdf, 0xff, 0xff, 0x01, 0x00, 0xf0,
   0xff, 0x7f, 0xe0, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xef, 0xff,
   0xff, 0x03, 0x00, 0xfc, 0xff, 0xff, 0xe1, 0xff, 0x07, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0xf3, 0xff, 0xff, 0xff, 0x0f, 0xfe, 0xff, 0xff, 0xe7, 0xff,
   0x87, 0x03, 0x00, 0x00, 0x00, 0xf8, 0xf8, 0xff, 0xff, 0xff, 0x3f, 0xff,
   0xff, 0xff, 0x0f, 0x00, 0xf1, 0x3f, 0x00, 0x00, 0x00, 0x18, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0x7f, 0xfc, 0x7f, 0x00, 0x00,
   0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xfe, 0xff, 0x01, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0xe0, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00,
   0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0x07, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0xfc, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01,
   0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x03, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0xfe, 0xff, 0xff, 0xff,
   0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8f, 0xff, 0x0f,
   0xff, 0xf1, 0xff, 0xff, 0xff, 0x0f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0x07, 0xff, 0x1f, 0xff, 0x14, 0x1c, 0x04, 0x60, 0x40, 0x00, 0x1c,
   0x06, 0x0e, 0x00, 0x18, 0xf8, 0x21, 0xe1, 0x1f, 0xff, 0x04, 0x00, 0x00,
   0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x20, 0xc0, 0x3f,
   0xff, 0xde, 0xe3, 0xd1, 0x0e, 0x4f, 0xa7, 0xe3, 0xd1, 0xf1, 0xb4, 0xc3,
   0x73, 0x2e, 0xcf, 0x3f, 0xff, 0x24, 0x14, 0x32, 0x93, 0xd0, 0x68, 0x14,
   0x32, 0x0a, 0xcd, 0x24, 0x64, 0xb1, 0xd0, 0x3f, 0xff, 0x25, 0x04, 0x12,
   0x91, 0x50, 0x28, 0x14, 0x12, 0x02, 0x45, 0x24, 0x64, 0xa1, 0x90, 0x3f,
   0xfe, 0xe5, 0xc7, 0x13, 0x91, 0x50, 0x28, 0xf4, 0x13, 0xe2, 0x45, 0xe4,
   0x67, 0xa1, 0x9f, 0x3f, 0xfe, 0x25, 0x20, 0x12, 0x91, 0x50, 0x28, 0x14,
   0x10, 0x12, 0x45, 0x24, 0x40, 0xa1, 0x80, 0x3f, 0xfe, 0x25, 0x10, 0x12,
   0x91, 0x50, 0x28, 0x14, 0x10, 0x0a, 0x45, 0x24, 0x00, 0xa1, 0x80, 0x3f,
   0xfc, 0x25, 0x14, 0x13, 0x91, 0x50, 0x28, 0x14, 0x12, 0x8a, 0x45, 0x24,
   0x04, 0xb1, 0x90, 0x3f, 0xf8, 0xdd, 0xe3, 0x12, 0x11, 0x4f, 0x28, 0xe4,
   0x11, 0x72, 0x45, 0xc4, 0x23, 0x2e, 0xcf, 0x1f, 0xf0, 0x01, 0x00, 0x00,
   0x00, 0x00, 0x83, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x1f,
   0xe0, 0x23, 0x18, 0xfc, 0xff, 0xf0, 0xff, 0x3f, 0xf8, 0x07, 0xfe, 0x3f,
   0xfc, 0x81, 0xf0, 0x0f, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xe0, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f,
   0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x07, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x80, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07,
   0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x03, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0xfc, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01,
   0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xe7, 0xff, 0xff, 0x00, 0x00, 0xe0, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x8b, 0xff, 0x3f, 0x00, 0x00, 0x80, 0xff, 0x47,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3d, 0xf0, 0x0f, 0x00,
   0x00, 0x00, 0x00, 0x70, 0xf8, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0x7f,
   0xfc, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x03, 0xf0, 0xff, 0x80,
   0xff, 0x9f, 0xff, 0xbf, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0,
   0x1f, 0xe0, 0x7f, 0x00, 0xf8, 0x01, 0xfc, 0x0f, 0xff, 0x01, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xc0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
   0x7c, 0x00, 0x00, 0x00
};

void u8g_DrawLogo(void) //,,Verschönerung" zum Zeit ,,schinden" am Anfang für UM6
{
	u8g_FirstPage(&u8g);
 	do
	{
   	u8g_DrawXBMP(&u8g, 1, 0, 126, 46, logo);
		u8g_SetFont(&u8g, u8g_font_6x10); //Schriftart
		u8g_DrawStr(&u8g, 20, 	60, "Kalibriere UM6...");
  } while(u8g_NextPage(&u8g));
}
////////////////////////////////////////////////////////////////////////////////
uint8_t disp_msg_i = 0;
uint8_t which_msg = 0;
uint8_t is_msg = 0;

#define DISP_MSG_I_TOP 13

#define TIMER_DISP_MSG 127 //SIEHE ROBOCUP.C!!!

char *disp_msg[DISP_MSG_I_TOP+1] = {
	"ok",
	"Warning 01: Battery low",
	"ERROR 10: SRF10 Front",
	"ERROR 11: SRF10 Right",
	"ERROR 12: SRF10 Back",
	"ERROR 13: SRF10 Left",
	"ERROR 20: MLX90614 L",
	"ERROR 21: MLX90614 R",
	"ERROR 30: UM6 Comm.",
	"INFO 01: Motor off",
	"INFO 02: Bluetooth on",
	"INFO 03: Setup",
	"ERROR 31: UM6 Drift",
	"ERROR 40: MAP"
};

void set_msg(void) //Hilfsfunktion
{
	which_msg = disp_msg_i+1;
	if(!(is_msg & (1<<0)))
	{
		is_msg |= (1<<0);
		is_msg |= (1<<1);
		timer_disp_msg = TIMER_DISP_MSG;
	}
}

void u8g_DrawInfo(void) //Malen der Batterie, Anzeige in %
{
	///////Infos////  X  /////////
	//  Karte   //Pfeil// Frei  //
	//  akt.    //     // hier: //
	//  Raum    /////////       //
	//          //Info //       //
	//          //Karte//       //
	//////////////////////////////
		
	u8g_DrawHLine(&u8g, 0, 6, 128); //Horizontale Abgrenzungslinie

	u8g_SetFont(&u8g, u8g_font_4x6); //Schriftart
	
	//////Batterie////////////
	u8g_DrawFrame(&u8g, 0, 0, 10, 5); //Batteriekörper
	u8g_DrawPixel(&u8g, 10, 2);
	int8_t batt_volumeVar = batt_percent/11; //Berechnung Füllung
	if(batt_volumeVar > 8)
		batt_volumeVar = 8;
	if(batt_volumeVar < 0)
		batt_volumeVar = 0;	
	u8g_DrawBox(&u8g, 1, 1, batt_volumeVar, 3); //Füllung

	//Anzeige daneben
	u8g_DrawLong(15,	5, batt_percent);
	u8g_DrawStr(&u8g, 25, 	5, "%");
	
	//Fehleranzeige daneben:
	if(timer_disp_msg == 0)
	{
		disp_msg_i ++;
		if(disp_msg_i == DISP_MSG_I_TOP)
		{
			disp_msg_i = 0;
			if(!(is_msg & (1<<1)))
			{
				which_msg = 0;
			}
			else
			{
				is_msg &= ~ (1<<1);
			}
		}
		is_msg &= ~ (1<<0);
	}

	switch(disp_msg_i)
	{
		case 0:		if(batt_percent < 20)
							{
								set_msg();
							}
						break;
		case 1:		if((check_srf & (1<<0)) ||
								 (check_srf & (1<<1)) ||
								 (check_srf & (1<<2)) ||
								 (check_srf & (1<<3)))
							{
								set_msg();
							}
						break;
		case 2:		if((check_srf & (1<<4)) ||
								 (check_srf & (1<<5)) ||
								 (check_srf & (1<<6)) ||
								 (check_srf & (1<<7)))
							{
								set_msg();
							}
						break;
		case 3:		if((check_srf & (1<<8)) ||
								 (check_srf & (1<<9)) ||
								 (check_srf & (1<<10)) ||
								 (check_srf & (1<<11)))
							{
								set_msg();
							}
						break;
		case 4:		if((check_srf & (1<<12)) ||
								 (check_srf & (1<<13)) ||
								 (check_srf & (1<<14)) ||
								 (check_srf & (1<<15)))
							{
								set_msg();
							}
						break;
		case 5:		if(check_mlx & (1<<0))
							{
								set_msg();
							}
						break;
		case 6:		if(check_mlx & (1<<1))
							{
								set_msg();
							}
						break;
		case 7:		if((check_um6 & (1<<0)) ||
								 (check_um6 & (1<<1)))
							{
								set_msg();
							}
						break;
		case 8:		if(motor_off)
							{
								set_msg();
							}
						break;
		case 9:		if(timer_bt_is_busy > 0)
							{
								set_msg();
							}
						break;
		case 10:	if(setup)
							{
								set_msg();
							}
						break;
		case 11:	if(check_um6 & (1<<2))
							{
								set_msg();
							}
		case 12:	if(!use_map)
							{
								set_msg();
							}
						break;
	}
	u8g_DrawStr(&u8g, 35, 	5, disp_msg[which_msg]);
}

void u8g_drawArrow(uint8_t size, uint8_t pos_x, uint8_t pos_y, uint8_t dir)
{
	uint8_t arrowlines_angle_pc = 2; //PC PerCent, logisch nicht korrekt, aber ok

	if(size > 10)
		arrowlines_angle_pc = 3;

	switch(dir)
	{
		case 1:	//NORTH
							u8g_DrawLine(&u8g, pos_x+(size/2), pos_y, pos_x-(size/2), pos_y);
							u8g_DrawLine(&u8g, pos_x+(size/2), pos_y, pos_x, pos_y-(size/arrowlines_angle_pc));  // -
							u8g_DrawLine(&u8g, pos_x+(size/2), pos_y, pos_x, pos_y+(size/arrowlines_angle_pc));  // -
						break;
		case 2:	//EAST
							u8g_DrawLine(&u8g, pos_x, pos_y+(size/2), pos_x, pos_y-(size/2));
							u8g_DrawLine(&u8g, pos_x, pos_y+(size/2), pos_x-(size/arrowlines_angle_pc),pos_y);  // /
							u8g_DrawLine(&u8g, pos_x, pos_y+(size/2), pos_x+(size/arrowlines_angle_pc), pos_y); //  \ //
						break;
		case 3:	//SOUTH
							u8g_DrawLine(&u8g, pos_x-(size/2), pos_y, pos_x+(size/2), pos_y); // –
							u8g_DrawLine(&u8g, pos_x-(size/2), pos_y, pos_x, pos_y-(size/arrowlines_angle_pc));  // -
							u8g_DrawLine(&u8g, pos_x-(size/2), pos_y, pos_x, pos_y+(size/arrowlines_angle_pc));  // -
						break;
		case 4:	//WEST
							u8g_DrawLine(&u8g, pos_x, pos_y-(size/2), pos_x, pos_y+(size/2)); // |
							u8g_DrawLine(&u8g, pos_x, pos_y-(size/2), pos_x-(size/arrowlines_angle_pc),pos_y);  // /
							u8g_DrawLine(&u8g, pos_x, pos_y-(size/2), pos_x+(size/arrowlines_angle_pc), pos_y); //  \ //
						break;
		default:  u8g_DrawStr(&u8g, pos_x-(size/2), pos_y, "ERROR");
						break;
	}
}

//////////////////////////////

#define SETUP_MODE_TOP 3 //Über der Zahl muss mode von vorne (bei 0) anfangen
	//Temp l
	//Temp r
	//Tarry
	//ok
#define SETUP_STEP_TOP 2
	//Cursor
	//1000er
	//100er

int8_t setup_mode = 0; //Temp l, r oder tarry?
int8_t setup_step = 0;

#define TIMER_INCR_ENTPR  500/25  //SIEHE ROBOCUP.C!!!
///////Hilfsfunktionen:

void setupStep_Fac(int16_t fac)
{
	switch(setup_mode)
	{
		case 0: 	mlx90614_l_th += (incr_delta * fac);
						break;
		case 1: 	mlx90614_r_th += (incr_delta * fac);
						break;
		case 2: 	use_tarry += incr_delta;
						break;
		case 3: 	setup = 0;
						break;
	}
}

///////

void u8g_DrawSetUp(void)
{
	u8g_SetFont(&u8g, u8g_font_4x6);

	if(get_incrOk() && (timer_incr_entpr == 0) && motor_off)
	{
		setup_step ++;
		if(setup_step > SETUP_STEP_TOP)
			setup_step = 0;

		timer_incr_entpr = TIMER_INCR_ENTPR;
	}

	switch(setup_step)
	{
		case 0:		setup_mode += incr_delta;
							if(setup_mode > SETUP_MODE_TOP)
								setup_mode = 0;
							else if(setup_mode < 0)
								setup_mode = SETUP_MODE_TOP;
						break;
		case 1:		setupStep_Fac(1000);
						break;
		case 2:		setupStep_Fac(100);
						break;
		case 3:		setupStep_Fac(10);
						break;
		case 4:		setupStep_Fac(1);
						break;
	}

	switch(setup_mode)
	{
		case 0: 	u8g_drawArrow(5, 60, 10, NORTH);
						break;
		case 1: 	u8g_drawArrow(5, 60, 17, NORTH);
						break;
		case 2: 	u8g_drawArrow(5, 60, 24, NORTH);
						break;
		case 3: 	u8g_drawArrow(5, 60, 57, NORTH);
						break;
	}

	u8g_DrawStr(&u8g,		0, 	13, "IR left:");	u8g_DrawLong(35,	13, mlx90614_l);	u8g_DrawLong(65,	13, mlx90614_l_th);

	u8g_DrawStr(&u8g, 	0, 20, "IR right:"); u8g_DrawLong(35, 20, mlx90614_r);		u8g_DrawLong(65, 20, mlx90614_r_th);
	
	u8g_DrawStr(&u8g, 0, 	27, "Tarry:"); u8g_DrawLong(65,	27, use_tarry);

	u8g_DrawStr(&u8g, 65, 	60, "ok");

	u8g_DrawLong(0,	50, setup_mode);
	u8g_DrawLong(0,	60, setup_step);
	////////////////

	//if(get_incrOk())
	//	setup = 0;
}
